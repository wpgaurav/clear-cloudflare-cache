{
  "version": 3,
  "sources": ["../../../../Development/Antigravity/clear-cloudflare-cache/src/purge-all.tsx", "../../../../Development/Antigravity/clear-cloudflare-cache/src/api.ts"],
  "sourcesContent": ["import {\n  Action,\n  ActionPanel,\n  Alert,\n  Color,\n  confirmAlert,\n  Icon,\n  List,\n  showToast,\n  Toast,\n} from \"@raycast/api\";\nimport { useState, useEffect } from \"react\";\nimport { fetchZones, purgeAllCache, Zone, showErrorToast, showSuccessToast } from \"./api\";\n\nexport default function PurgeAllCommand() {\n  const [zones, setZones] = useState<Zone[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    loadZones();\n  }, []);\n\n  async function loadZones() {\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const fetchedZones = await fetchZones();\n      setZones(fetchedZones);\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : \"Failed to fetch zones\";\n      setError(errorMessage);\n      await showErrorToast(\"Failed to load zones\", err instanceof Error ? err : undefined);\n    } finally {\n      setIsLoading(false);\n    }\n  }\n\n  async function handlePurgeAll(zone: Zone) {\n    const confirmed = await confirmAlert({\n      title: \"Purge Entire Cache?\",\n      message: `This will clear ALL cached content for ${zone.name}. This action cannot be undone.`,\n      primaryAction: {\n        title: \"Purge All\",\n        style: Alert.ActionStyle.Destructive,\n      },\n    });\n\n    if (!confirmed) return;\n\n    await showToast({\n      style: Toast.Style.Animated,\n      title: \"Purging cache...\",\n      message: zone.name,\n    });\n\n    try {\n      await purgeAllCache(zone.id);\n      await showSuccessToast(`Cache purged for ${zone.name}`);\n    } catch (err) {\n      await showErrorToast(\"Failed to purge cache\", err instanceof Error ? err : undefined);\n    }\n  }\n\n  function getStatusIcon(zone: Zone) {\n    if (zone.paused) {\n      return { source: Icon.Pause, tintColor: Color.Orange };\n    }\n    if (zone.status === \"active\") {\n      return { source: Icon.CheckCircle, tintColor: Color.Green };\n    }\n    return { source: Icon.Circle, tintColor: Color.SecondaryText };\n  }\n\n  if (error && zones.length === 0) {\n    return (\n      <List>\n        <List.EmptyView\n          icon={Icon.ExclamationMark}\n          title=\"Failed to Load Zones\"\n          description={error}\n          actions={\n            <ActionPanel>\n              <Action title=\"Retry\" icon={Icon.ArrowClockwise} onAction={loadZones} />\n            </ActionPanel>\n          }\n        />\n      </List>\n    );\n  }\n\n  return (\n    <List isLoading={isLoading} searchBarPlaceholder=\"Search zones...\">\n      <List.Section title=\"Cloudflare Zones\" subtitle={`${zones.length} sites`}>\n        {zones.map((zone) => (\n          <List.Item\n            key={zone.id}\n            title={zone.name}\n            subtitle={zone.id}\n            icon={getStatusIcon(zone)}\n            accessories={[\n              {\n                tag: {\n                  value: zone.status,\n                  color: zone.status === \"active\" ? Color.Green : Color.SecondaryText,\n                },\n              },\n            ]}\n            actions={\n              <ActionPanel>\n                <ActionPanel.Section>\n                  <Action\n                    title=\"Purge All Cache\"\n                    icon={{ source: Icon.Trash, tintColor: Color.Red }}\n                    style={Action.Style.Destructive}\n                    onAction={() => handlePurgeAll(zone)}\n                  />\n                </ActionPanel.Section>\n                <ActionPanel.Section>\n                  <Action.CopyToClipboard\n                    title=\"Copy Zone ID\"\n                    content={zone.id}\n                    shortcut={{ modifiers: [\"cmd\"], key: \"c\" }}\n                  />\n                  <Action.CopyToClipboard\n                    title=\"Copy Domain\"\n                    content={zone.name}\n                    shortcut={{ modifiers: [\"cmd\", \"shift\"], key: \"c\" }}\n                  />\n                </ActionPanel.Section>\n                <ActionPanel.Section>\n                  <Action\n                    title=\"Refresh Zones\"\n                    icon={Icon.ArrowClockwise}\n                    shortcut={{ modifiers: [\"cmd\"], key: \"r\" }}\n                    onAction={loadZones}\n                  />\n                </ActionPanel.Section>\n              </ActionPanel>\n            }\n          />\n        ))}\n      </List.Section>\n    </List>\n  );\n}\n", "import { getPreferenceValues, showToast, Toast } from \"@raycast/api\";\n\nconst API_BASE = \"https://api.cloudflare.com/client/v4\";\n\ninterface Preferences {\n  apiToken: string;\n  defaultZoneId?: string;\n}\n\nexport interface Zone {\n  id: string;\n  name: string;\n  status: string;\n  paused: boolean;\n}\n\ninterface CloudflareResponse<T> {\n  success: boolean;\n  errors: Array<{ code: number; message: string }>;\n  messages: string[];\n  result: T;\n}\n\ninterface ZonesResult {\n  result: Zone[];\n  result_info: {\n    page: number;\n    per_page: number;\n    total_count: number;\n    total_pages: number;\n  };\n}\n\ninterface PurgeResult {\n  id: string;\n}\n\nfunction getHeaders(): HeadersInit {\n  const { apiToken } = getPreferenceValues<Preferences>();\n  return {\n    Authorization: `Bearer ${apiToken}`,\n    \"Content-Type\": \"application/json\",\n  };\n}\n\nexport async function fetchZones(): Promise<Zone[]> {\n  try {\n    const response = await fetch(`${API_BASE}/zones?per_page=50`, {\n      method: \"GET\",\n      headers: getHeaders(),\n    });\n\n    const data = (await response.json()) as CloudflareResponse<Zone[]> & ZonesResult;\n\n    if (!data.success) {\n      const errorMsg = data.errors.map((e) => e.message).join(\", \");\n      throw new Error(errorMsg || \"Failed to fetch zones\");\n    }\n\n    return data.result;\n  } catch (error) {\n    console.error(\"Error fetching zones:\", error);\n    throw error;\n  }\n}\n\nexport async function purgeAllCache(zoneId: string): Promise<boolean> {\n  try {\n    const response = await fetch(`${API_BASE}/zones/${zoneId}/purge_cache`, {\n      method: \"POST\",\n      headers: getHeaders(),\n      body: JSON.stringify({ purge_everything: true }),\n    });\n\n    const data = (await response.json()) as CloudflareResponse<PurgeResult>;\n\n    if (!data.success) {\n      const errorMsg = data.errors.map((e) => e.message).join(\", \");\n      throw new Error(errorMsg || \"Failed to purge cache\");\n    }\n\n    return true;\n  } catch (error) {\n    console.error(\"Error purging all cache:\", error);\n    throw error;\n  }\n}\n\nexport async function purgeUrls(zoneId: string, urls: string[]): Promise<boolean> {\n  if (urls.length === 0) {\n    throw new Error(\"No URLs provided\");\n  }\n\n  if (urls.length > 30) {\n    throw new Error(\"Maximum 30 URLs per request. Split into multiple batches.\");\n  }\n\n  try {\n    const response = await fetch(`${API_BASE}/zones/${zoneId}/purge_cache`, {\n      method: \"POST\",\n      headers: getHeaders(),\n      body: JSON.stringify({ files: urls }),\n    });\n\n    const data = (await response.json()) as CloudflareResponse<PurgeResult>;\n\n    if (!data.success) {\n      const errorMsg = data.errors.map((e) => e.message).join(\", \");\n      throw new Error(errorMsg || \"Failed to purge URLs\");\n    }\n\n    return true;\n  } catch (error) {\n    console.error(\"Error purging URLs:\", error);\n    throw error;\n  }\n}\n\nexport async function purgeTags(zoneId: string, tags: string[]): Promise<boolean> {\n  if (tags.length === 0) {\n    throw new Error(\"No cache tags provided\");\n  }\n\n  try {\n    const response = await fetch(`${API_BASE}/zones/${zoneId}/purge_cache`, {\n      method: \"POST\",\n      headers: getHeaders(),\n      body: JSON.stringify({ tags }),\n    });\n\n    const data = (await response.json()) as CloudflareResponse<PurgeResult>;\n\n    if (!data.success) {\n      const errorMsg = data.errors.map((e) => e.message).join(\", \");\n      throw new Error(errorMsg || \"Failed to purge by tags\");\n    }\n\n    return true;\n  } catch (error) {\n    console.error(\"Error purging by tags:\", error);\n    throw error;\n  }\n}\n\nexport async function purgePrefix(zoneId: string, prefixes: string[]): Promise<boolean> {\n  if (prefixes.length === 0) {\n    throw new Error(\"No prefixes provided\");\n  }\n\n  try {\n    const response = await fetch(`${API_BASE}/zones/${zoneId}/purge_cache`, {\n      method: \"POST\",\n      headers: getHeaders(),\n      body: JSON.stringify({ prefixes }),\n    });\n\n    const data = (await response.json()) as CloudflareResponse<PurgeResult>;\n\n    if (!data.success) {\n      const errorMsg = data.errors.map((e) => e.message).join(\", \");\n      throw new Error(errorMsg || \"Failed to purge by prefix\");\n    }\n\n    return true;\n  } catch (error) {\n    console.error(\"Error purging by prefix:\", error);\n    throw error;\n  }\n}\n\nexport function getDefaultZoneId(): string | undefined {\n  const { defaultZoneId } = getPreferenceValues<Preferences>();\n  return defaultZoneId;\n}\n\nexport function extractDomainFromUrl(url: string): string | null {\n  try {\n    const urlObj = new URL(url);\n    return urlObj.hostname;\n  } catch {\n    return null;\n  }\n}\n\nexport async function findZoneByDomain(domain: string): Promise<Zone | null> {\n  const zones = await fetchZones();\n  \n  // Try exact match first\n  let zone = zones.find((z) => z.name === domain);\n  if (zone) return zone;\n\n  // Try to find parent domain match (e.g., subdomain.example.com -> example.com)\n  const parts = domain.split(\".\");\n  while (parts.length > 1) {\n    parts.shift();\n    const parentDomain = parts.join(\".\");\n    zone = zones.find((z) => z.name === parentDomain);\n    if (zone) return zone;\n  }\n\n  return null;\n}\n\nexport async function showErrorToast(message: string, error?: Error) {\n  await showToast({\n    style: Toast.Style.Failure,\n    title: message,\n    message: error?.message,\n  });\n}\n\nexport async function showSuccessToast(message: string) {\n  await showToast({\n    style: Toast.Style.Success,\n    title: message,\n  });\n}\n"],
  "mappings": "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",
  "names": ["purge_all_exports", "__export", "PurgeAllCommand", "__toCommonJS", "import_api", "import_react", "import_api", "API_BASE", "getHeaders", "apiToken", "fetchZones", "data", "errorMsg", "e", "error", "purgeAllCache", "zoneId", "showErrorToast", "message", "error", "showSuccessToast", "import_jsx_runtime", "PurgeAllCommand", "zones", "setZones", "isLoading", "setIsLoading", "error", "setError", "loadZones", "fetchedZones", "fetchZones", "err", "errorMessage", "showErrorToast", "handlePurgeAll", "zone", "purgeAllCache", "showSuccessToast", "getStatusIcon"]
}
