{
  "version": 3,
  "sources": ["../../../../Development/Antigravity/clear-cloudflare-cache/src/purge-urls.tsx", "../../../../Development/Antigravity/clear-cloudflare-cache/src/api.ts"],
  "sourcesContent": ["import {\n  Action,\n  ActionPanel,\n  Color,\n  Form,\n  Icon,\n  List,\n  showToast,\n  Toast,\n  useNavigation,\n} from \"@raycast/api\";\nimport { useState, useEffect } from \"react\";\nimport {\n  fetchZones,\n  purgeUrls,\n  Zone,\n  showErrorToast,\n  showSuccessToast,\n  extractDomainFromUrl,\n} from \"./api\";\n\nexport default function PurgeUrlsCommand() {\n  const [zones, setZones] = useState<Zone[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const { push } = useNavigation();\n\n  useEffect(() => {\n    loadZones();\n  }, []);\n\n  async function loadZones() {\n    setIsLoading(true);\n    try {\n      const fetchedZones = await fetchZones();\n      setZones(fetchedZones);\n    } catch (err) {\n      await showErrorToast(\"Failed to load zones\", err instanceof Error ? err : undefined);\n    } finally {\n      setIsLoading(false);\n    }\n  }\n\n  function getStatusIcon(zone: Zone) {\n    if (zone.paused) {\n      return { source: Icon.Pause, tintColor: Color.Orange };\n    }\n    if (zone.status === \"active\") {\n      return { source: Icon.CheckCircle, tintColor: Color.Green };\n    }\n    return { source: Icon.Circle, tintColor: Color.SecondaryText };\n  }\n\n  return (\n    <List isLoading={isLoading} searchBarPlaceholder=\"Select a zone to purge URLs from...\">\n      <List.Section title=\"Select Zone\" subtitle=\"Choose the site to purge URLs from\">\n        {zones.map((zone) => (\n          <List.Item\n            key={zone.id}\n            title={zone.name}\n            subtitle={zone.id}\n            icon={getStatusIcon(zone)}\n            accessories={[\n              {\n                tag: {\n                  value: zone.status,\n                  color: zone.status === \"active\" ? Color.Green : Color.SecondaryText,\n                },\n              },\n            ]}\n            actions={\n              <ActionPanel>\n                <Action\n                  title=\"Enter URLs to Purge\"\n                  icon={Icon.List}\n                  onAction={() => push(<UrlInputForm zone={zone} />)}\n                />\n                <Action\n                  title=\"Refresh Zones\"\n                  icon={Icon.ArrowClockwise}\n                  shortcut={{ modifiers: [\"cmd\"], key: \"r\" }}\n                  onAction={loadZones}\n                />\n              </ActionPanel>\n            }\n          />\n        ))}\n      </List.Section>\n    </List>\n  );\n}\n\ninterface UrlInputFormProps {\n  zone: Zone;\n}\n\nfunction UrlInputForm({ zone }: UrlInputFormProps) {\n  const [urls, setUrls] = useState(\"\");\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [urlError, setUrlError] = useState<string | undefined>();\n  const { pop } = useNavigation();\n\n  function validateUrls(value: string): string[] {\n    const lines = value\n      .split(\"\\n\")\n      .map((line) => line.trim())\n      .filter((line) => line.length > 0);\n\n    const validUrls: string[] = [];\n    const invalidUrls: string[] = [];\n\n    for (const line of lines) {\n      try {\n        const url = new URL(line);\n        if (url.protocol === \"http:\" || url.protocol === \"https:\") {\n          validUrls.push(line);\n        } else {\n          invalidUrls.push(line);\n        }\n      } catch {\n        invalidUrls.push(line);\n      }\n    }\n\n    if (invalidUrls.length > 0) {\n      setUrlError(`Invalid URLs: ${invalidUrls.slice(0, 3).join(\", \")}${invalidUrls.length > 3 ? \"...\" : \"\"}`);\n    } else {\n      setUrlError(undefined);\n    }\n\n    return validUrls;\n  }\n\n  async function handleSubmit(values: { urls: string }) {\n    const validUrls = validateUrls(values.urls);\n\n    if (validUrls.length === 0) {\n      setUrlError(\"Please enter at least one valid URL\");\n      return;\n    }\n\n    if (validUrls.length > 30) {\n      setUrlError(\"Maximum 30 URLs per request. Please reduce the number of URLs.\");\n      return;\n    }\n\n    // Validate URLs belong to the zone\n    const wrongDomainUrls = validUrls.filter((url) => {\n      const domain = extractDomainFromUrl(url);\n      if (!domain) return true;\n      return !domain.endsWith(zone.name) && domain !== zone.name;\n    });\n\n    if (wrongDomainUrls.length > 0) {\n      setUrlError(`Some URLs don't belong to ${zone.name}: ${wrongDomainUrls[0]}`);\n      return;\n    }\n\n    setIsSubmitting(true);\n\n    await showToast({\n      style: Toast.Style.Animated,\n      title: \"Purging URLs...\",\n      message: `${validUrls.length} URL(s)`,\n    });\n\n    try {\n      await purgeUrls(zone.id, validUrls);\n      await showSuccessToast(`Purged ${validUrls.length} URL(s) from ${zone.name}`);\n      pop();\n    } catch (err) {\n      await showErrorToast(\"Failed to purge URLs\", err instanceof Error ? err : undefined);\n    } finally {\n      setIsSubmitting(false);\n    }\n  }\n\n  return (\n    <Form\n      isLoading={isSubmitting}\n      actions={\n        <ActionPanel>\n          <Action.SubmitForm\n            title=\"Purge URLs\"\n            icon={{ source: Icon.Trash, tintColor: Color.Red }}\n            onSubmit={handleSubmit}\n          />\n        </ActionPanel>\n      }\n    >\n      <Form.Description title=\"Zone\" text={zone.name} />\n      <Form.TextArea\n        id=\"urls\"\n        title=\"URLs to Purge\"\n        placeholder={`https://${zone.name}/page-1\\nhttps://${zone.name}/page-2\\nhttps://${zone.name}/css/style.css`}\n        info=\"Enter one URL per line. Maximum 30 URLs per request. URLs must include the full path including https://\"\n        value={urls}\n        onChange={setUrls}\n        error={urlError}\n      />\n      <Form.Description\n        title=\"Tips\"\n        text=\"\u2022 Include query strings if the cached URL has them\n\u2022 Use exact URLs as they appear in browser\n\u2022 For cache tags or prefix purge, use Quick Purge command\"\n      />\n    </Form>\n  );\n}\n", "import { getPreferenceValues, showToast, Toast } from \"@raycast/api\";\n\nconst API_BASE = \"https://api.cloudflare.com/client/v4\";\n\ninterface Preferences {\n  apiToken: string;\n  defaultZoneId?: string;\n}\n\nexport interface Zone {\n  id: string;\n  name: string;\n  status: string;\n  paused: boolean;\n}\n\ninterface CloudflareResponse<T> {\n  success: boolean;\n  errors: Array<{ code: number; message: string }>;\n  messages: string[];\n  result: T;\n}\n\ninterface ZonesResult {\n  result: Zone[];\n  result_info: {\n    page: number;\n    per_page: number;\n    total_count: number;\n    total_pages: number;\n  };\n}\n\ninterface PurgeResult {\n  id: string;\n}\n\nfunction getHeaders(): HeadersInit {\n  const { apiToken } = getPreferenceValues<Preferences>();\n  return {\n    Authorization: `Bearer ${apiToken}`,\n    \"Content-Type\": \"application/json\",\n  };\n}\n\nexport async function fetchZones(): Promise<Zone[]> {\n  try {\n    const response = await fetch(`${API_BASE}/zones?per_page=50`, {\n      method: \"GET\",\n      headers: getHeaders(),\n    });\n\n    const data = (await response.json()) as CloudflareResponse<Zone[]> & ZonesResult;\n\n    if (!data.success) {\n      const errorMsg = data.errors.map((e) => e.message).join(\", \");\n      throw new Error(errorMsg || \"Failed to fetch zones\");\n    }\n\n    return data.result;\n  } catch (error) {\n    console.error(\"Error fetching zones:\", error);\n    throw error;\n  }\n}\n\nexport async function purgeAllCache(zoneId: string): Promise<boolean> {\n  try {\n    const response = await fetch(`${API_BASE}/zones/${zoneId}/purge_cache`, {\n      method: \"POST\",\n      headers: getHeaders(),\n      body: JSON.stringify({ purge_everything: true }),\n    });\n\n    const data = (await response.json()) as CloudflareResponse<PurgeResult>;\n\n    if (!data.success) {\n      const errorMsg = data.errors.map((e) => e.message).join(\", \");\n      throw new Error(errorMsg || \"Failed to purge cache\");\n    }\n\n    return true;\n  } catch (error) {\n    console.error(\"Error purging all cache:\", error);\n    throw error;\n  }\n}\n\nexport async function purgeUrls(zoneId: string, urls: string[]): Promise<boolean> {\n  if (urls.length === 0) {\n    throw new Error(\"No URLs provided\");\n  }\n\n  if (urls.length > 30) {\n    throw new Error(\"Maximum 30 URLs per request. Split into multiple batches.\");\n  }\n\n  try {\n    const response = await fetch(`${API_BASE}/zones/${zoneId}/purge_cache`, {\n      method: \"POST\",\n      headers: getHeaders(),\n      body: JSON.stringify({ files: urls }),\n    });\n\n    const data = (await response.json()) as CloudflareResponse<PurgeResult>;\n\n    if (!data.success) {\n      const errorMsg = data.errors.map((e) => e.message).join(\", \");\n      throw new Error(errorMsg || \"Failed to purge URLs\");\n    }\n\n    return true;\n  } catch (error) {\n    console.error(\"Error purging URLs:\", error);\n    throw error;\n  }\n}\n\nexport async function purgeTags(zoneId: string, tags: string[]): Promise<boolean> {\n  if (tags.length === 0) {\n    throw new Error(\"No cache tags provided\");\n  }\n\n  try {\n    const response = await fetch(`${API_BASE}/zones/${zoneId}/purge_cache`, {\n      method: \"POST\",\n      headers: getHeaders(),\n      body: JSON.stringify({ tags }),\n    });\n\n    const data = (await response.json()) as CloudflareResponse<PurgeResult>;\n\n    if (!data.success) {\n      const errorMsg = data.errors.map((e) => e.message).join(\", \");\n      throw new Error(errorMsg || \"Failed to purge by tags\");\n    }\n\n    return true;\n  } catch (error) {\n    console.error(\"Error purging by tags:\", error);\n    throw error;\n  }\n}\n\nexport async function purgePrefix(zoneId: string, prefixes: string[]): Promise<boolean> {\n  if (prefixes.length === 0) {\n    throw new Error(\"No prefixes provided\");\n  }\n\n  try {\n    const response = await fetch(`${API_BASE}/zones/${zoneId}/purge_cache`, {\n      method: \"POST\",\n      headers: getHeaders(),\n      body: JSON.stringify({ prefixes }),\n    });\n\n    const data = (await response.json()) as CloudflareResponse<PurgeResult>;\n\n    if (!data.success) {\n      const errorMsg = data.errors.map((e) => e.message).join(\", \");\n      throw new Error(errorMsg || \"Failed to purge by prefix\");\n    }\n\n    return true;\n  } catch (error) {\n    console.error(\"Error purging by prefix:\", error);\n    throw error;\n  }\n}\n\nexport function getDefaultZoneId(): string | undefined {\n  const { defaultZoneId } = getPreferenceValues<Preferences>();\n  return defaultZoneId;\n}\n\nexport function extractDomainFromUrl(url: string): string | null {\n  try {\n    const urlObj = new URL(url);\n    return urlObj.hostname;\n  } catch {\n    return null;\n  }\n}\n\nexport async function findZoneByDomain(domain: string): Promise<Zone | null> {\n  const zones = await fetchZones();\n  \n  // Try exact match first\n  let zone = zones.find((z) => z.name === domain);\n  if (zone) return zone;\n\n  // Try to find parent domain match (e.g., subdomain.example.com -> example.com)\n  const parts = domain.split(\".\");\n  while (parts.length > 1) {\n    parts.shift();\n    const parentDomain = parts.join(\".\");\n    zone = zones.find((z) => z.name === parentDomain);\n    if (zone) return zone;\n  }\n\n  return null;\n}\n\nexport async function showErrorToast(message: string, error?: Error) {\n  await showToast({\n    style: Toast.Style.Failure,\n    title: message,\n    message: error?.message,\n  });\n}\n\nexport async function showSuccessToast(message: string) {\n  await showToast({\n    style: Toast.Style.Success,\n    title: message,\n  });\n}\n"],
  "mappings": "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",
  "names": ["purge_urls_exports", "__export", "PurgeUrlsCommand", "__toCommonJS", "import_api", "import_react", "import_api", "API_BASE", "getHeaders", "apiToken", "fetchZones", "data", "errorMsg", "e", "error", "purgeUrls", "zoneId", "urls", "data", "API_BASE", "getHeaders", "errorMsg", "e", "error", "extractDomainFromUrl", "url", "showErrorToast", "message", "error", "showSuccessToast", "import_jsx_runtime", "PurgeUrlsCommand", "zones", "setZones", "isLoading", "setIsLoading", "push", "loadZones", "fetchedZones", "fetchZones", "err", "showErrorToast", "getStatusIcon", "zone", "UrlInputForm", "urls", "setUrls", "isSubmitting", "setIsSubmitting", "urlError", "setUrlError", "pop", "validateUrls", "value", "lines", "line", "validUrls", "invalidUrls", "url", "handleSubmit", "values", "wrongDomainUrls", "domain", "extractDomainFromUrl", "purgeUrls", "showSuccessToast"]
}
