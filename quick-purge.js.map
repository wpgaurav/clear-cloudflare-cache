{
  "version": 3,
  "sources": ["../../../../Development/Antigravity/clear-cloudflare-cache/src/quick-purge.tsx", "../../../../Development/Antigravity/clear-cloudflare-cache/src/api.ts"],
  "sourcesContent": ["import {\n  Action,\n  ActionPanel,\n  Clipboard,\n  Color,\n  Form,\n  Icon,\n  showToast,\n  Toast,\n  popToRoot,\n  getPreferenceValues,\n} from \"@raycast/api\";\nimport { useState, useEffect } from \"react\";\nimport {\n  fetchZones,\n  purgeUrls,\n  Zone,\n  showErrorToast,\n  showSuccessToast,\n  extractDomainFromUrl,\n  findZoneByDomain,\n  getDefaultZoneId,\n} from \"./api\";\n\ninterface Preferences {\n  apiToken: string;\n  defaultZoneId?: string;\n}\n\nexport default function QuickPurgeCommand() {\n  const [url, setUrl] = useState(\"\");\n  const [selectedZoneId, setSelectedZoneId] = useState<string>(\"\");\n  const [zones, setZones] = useState<Zone[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [urlError, setUrlError] = useState<string | undefined>();\n  const [detectedZone, setDetectedZone] = useState<Zone | null>(null);\n\n  useEffect(() => {\n    initialize();\n  }, []);\n\n  useEffect(() => {\n    if (url && zones.length > 0) {\n      detectZone(url);\n    }\n  }, [url, zones]);\n\n  async function initialize() {\n    setIsLoading(true);\n\n    try {\n      // Load zones\n      const fetchedZones = await fetchZones();\n      setZones(fetchedZones);\n\n      // Set default zone if configured\n      const defaultZoneId = getDefaultZoneId();\n      if (defaultZoneId) {\n        setSelectedZoneId(defaultZoneId);\n      }\n\n      // Check clipboard for URL\n      const clipboardText = await Clipboard.readText();\n      if (clipboardText) {\n        const trimmed = clipboardText.trim();\n        if (isValidUrl(trimmed)) {\n          setUrl(trimmed);\n          \n          // Try to detect zone from clipboard URL\n          const domain = extractDomainFromUrl(trimmed);\n          if (domain) {\n            const zone = await findZoneByDomain(domain);\n            if (zone) {\n              setSelectedZoneId(zone.id);\n              setDetectedZone(zone);\n            }\n          }\n        }\n      }\n    } catch (err) {\n      await showErrorToast(\"Failed to initialize\", err instanceof Error ? err : undefined);\n    } finally {\n      setIsLoading(false);\n    }\n  }\n\n  function isValidUrl(text: string): boolean {\n    try {\n      const url = new URL(text);\n      return url.protocol === \"http:\" || url.protocol === \"https:\";\n    } catch {\n      return false;\n    }\n  }\n\n  async function detectZone(urlValue: string) {\n    if (!isValidUrl(urlValue)) {\n      setDetectedZone(null);\n      return;\n    }\n\n    const domain = extractDomainFromUrl(urlValue);\n    if (!domain) {\n      setDetectedZone(null);\n      return;\n    }\n\n    const zone = zones.find((z) => domain.endsWith(z.name) || domain === z.name);\n    if (zone && zone.id !== selectedZoneId) {\n      setDetectedZone(zone);\n      setSelectedZoneId(zone.id);\n    } else if (!zone) {\n      setDetectedZone(null);\n    }\n  }\n\n  function validateUrl(value: string): boolean {\n    if (!value.trim()) {\n      setUrlError(\"URL is required\");\n      return false;\n    }\n\n    if (!isValidUrl(value)) {\n      setUrlError(\"Please enter a valid URL starting with http:// or https://\");\n      return false;\n    }\n\n    setUrlError(undefined);\n    return true;\n  }\n\n  async function handleSubmit(values: { url: string; zoneId: string }) {\n    if (!validateUrl(values.url)) {\n      return;\n    }\n\n    if (!values.zoneId) {\n      await showErrorToast(\"Please select a zone\");\n      return;\n    }\n\n    const zone = zones.find((z) => z.id === values.zoneId);\n    if (!zone) {\n      await showErrorToast(\"Invalid zone selected\");\n      return;\n    }\n\n    // Validate URL belongs to zone\n    const domain = extractDomainFromUrl(values.url);\n    if (domain && !domain.endsWith(zone.name) && domain !== zone.name) {\n      setUrlError(`URL domain (${domain}) doesn't match zone (${zone.name})`);\n      return;\n    }\n\n    setIsSubmitting(true);\n\n    await showToast({\n      style: Toast.Style.Animated,\n      title: \"Purging URL...\",\n    });\n\n    try {\n      await purgeUrls(values.zoneId, [values.url.trim()]);\n      await showSuccessToast(`Purged: ${values.url}`);\n      await popToRoot();\n    } catch (err) {\n      await showErrorToast(\"Failed to purge URL\", err instanceof Error ? err : undefined);\n    } finally {\n      setIsSubmitting(false);\n    }\n  }\n\n  return (\n    <Form\n      isLoading={isLoading || isSubmitting}\n      actions={\n        <ActionPanel>\n          <Action.SubmitForm\n            title=\"Purge URL\"\n            icon={{ source: Icon.Trash, tintColor: Color.Red }}\n            onSubmit={handleSubmit}\n          />\n          <Action\n            title=\"Paste from Clipboard\"\n            icon={Icon.Clipboard}\n            shortcut={{ modifiers: [\"cmd\", \"shift\"], key: \"v\" }}\n            onAction={async () => {\n              const text = await Clipboard.readText();\n              if (text && isValidUrl(text.trim())) {\n                setUrl(text.trim());\n              }\n            }}\n          />\n        </ActionPanel>\n      }\n    >\n      <Form.TextField\n        id=\"url\"\n        title=\"URL to Purge\"\n        placeholder=\"https://example.com/page-to-purge\"\n        value={url}\n        onChange={(value) => {\n          setUrl(value);\n          if (value) validateUrl(value);\n        }}\n        error={urlError}\n        info=\"The exact URL to remove from Cloudflare's cache\"\n      />\n\n      <Form.Dropdown\n        id=\"zoneId\"\n        title=\"Zone\"\n        value={selectedZoneId}\n        onChange={setSelectedZoneId}\n        info={detectedZone ? `Auto-detected: ${detectedZone.name}` : \"Select the Cloudflare zone for this URL\"}\n      >\n        <Form.Dropdown.Item value=\"\" title=\"Select a zone...\" />\n        {zones.map((zone) => (\n          <Form.Dropdown.Item\n            key={zone.id}\n            value={zone.id}\n            title={zone.name}\n            icon={\n              zone.status === \"active\"\n                ? { source: Icon.CheckCircle, tintColor: Color.Green }\n                : { source: Icon.Circle, tintColor: Color.SecondaryText }\n            }\n          />\n        ))}\n      </Form.Dropdown>\n\n      {detectedZone && (\n        <Form.Description\n          title=\"Auto-detected\"\n          text={`Zone \"${detectedZone.name}\" was automatically selected based on the URL domain.`}\n        />\n      )}\n\n      <Form.Description\n        title=\"Notes\"\n        text=\"\u2022 URL must include the full path (https://...)\n\u2022 Include query strings if the cached version has them\n\u2022 Changes take effect within seconds globally\"\n      />\n    </Form>\n  );\n}\n", "import { getPreferenceValues, showToast, Toast } from \"@raycast/api\";\n\nconst API_BASE = \"https://api.cloudflare.com/client/v4\";\n\ninterface Preferences {\n  apiToken: string;\n  defaultZoneId?: string;\n}\n\nexport interface Zone {\n  id: string;\n  name: string;\n  status: string;\n  paused: boolean;\n}\n\ninterface CloudflareResponse<T> {\n  success: boolean;\n  errors: Array<{ code: number; message: string }>;\n  messages: string[];\n  result: T;\n}\n\ninterface ZonesResult {\n  result: Zone[];\n  result_info: {\n    page: number;\n    per_page: number;\n    total_count: number;\n    total_pages: number;\n  };\n}\n\ninterface PurgeResult {\n  id: string;\n}\n\nfunction getHeaders(): HeadersInit {\n  const { apiToken } = getPreferenceValues<Preferences>();\n  return {\n    Authorization: `Bearer ${apiToken}`,\n    \"Content-Type\": \"application/json\",\n  };\n}\n\nexport async function fetchZones(): Promise<Zone[]> {\n  try {\n    const response = await fetch(`${API_BASE}/zones?per_page=50`, {\n      method: \"GET\",\n      headers: getHeaders(),\n    });\n\n    const data = (await response.json()) as CloudflareResponse<Zone[]> & ZonesResult;\n\n    if (!data.success) {\n      const errorMsg = data.errors.map((e) => e.message).join(\", \");\n      throw new Error(errorMsg || \"Failed to fetch zones\");\n    }\n\n    return data.result;\n  } catch (error) {\n    console.error(\"Error fetching zones:\", error);\n    throw error;\n  }\n}\n\nexport async function purgeAllCache(zoneId: string): Promise<boolean> {\n  try {\n    const response = await fetch(`${API_BASE}/zones/${zoneId}/purge_cache`, {\n      method: \"POST\",\n      headers: getHeaders(),\n      body: JSON.stringify({ purge_everything: true }),\n    });\n\n    const data = (await response.json()) as CloudflareResponse<PurgeResult>;\n\n    if (!data.success) {\n      const errorMsg = data.errors.map((e) => e.message).join(\", \");\n      throw new Error(errorMsg || \"Failed to purge cache\");\n    }\n\n    return true;\n  } catch (error) {\n    console.error(\"Error purging all cache:\", error);\n    throw error;\n  }\n}\n\nexport async function purgeUrls(zoneId: string, urls: string[]): Promise<boolean> {\n  if (urls.length === 0) {\n    throw new Error(\"No URLs provided\");\n  }\n\n  if (urls.length > 30) {\n    throw new Error(\"Maximum 30 URLs per request. Split into multiple batches.\");\n  }\n\n  try {\n    const response = await fetch(`${API_BASE}/zones/${zoneId}/purge_cache`, {\n      method: \"POST\",\n      headers: getHeaders(),\n      body: JSON.stringify({ files: urls }),\n    });\n\n    const data = (await response.json()) as CloudflareResponse<PurgeResult>;\n\n    if (!data.success) {\n      const errorMsg = data.errors.map((e) => e.message).join(\", \");\n      throw new Error(errorMsg || \"Failed to purge URLs\");\n    }\n\n    return true;\n  } catch (error) {\n    console.error(\"Error purging URLs:\", error);\n    throw error;\n  }\n}\n\nexport async function purgeTags(zoneId: string, tags: string[]): Promise<boolean> {\n  if (tags.length === 0) {\n    throw new Error(\"No cache tags provided\");\n  }\n\n  try {\n    const response = await fetch(`${API_BASE}/zones/${zoneId}/purge_cache`, {\n      method: \"POST\",\n      headers: getHeaders(),\n      body: JSON.stringify({ tags }),\n    });\n\n    const data = (await response.json()) as CloudflareResponse<PurgeResult>;\n\n    if (!data.success) {\n      const errorMsg = data.errors.map((e) => e.message).join(\", \");\n      throw new Error(errorMsg || \"Failed to purge by tags\");\n    }\n\n    return true;\n  } catch (error) {\n    console.error(\"Error purging by tags:\", error);\n    throw error;\n  }\n}\n\nexport async function purgePrefix(zoneId: string, prefixes: string[]): Promise<boolean> {\n  if (prefixes.length === 0) {\n    throw new Error(\"No prefixes provided\");\n  }\n\n  try {\n    const response = await fetch(`${API_BASE}/zones/${zoneId}/purge_cache`, {\n      method: \"POST\",\n      headers: getHeaders(),\n      body: JSON.stringify({ prefixes }),\n    });\n\n    const data = (await response.json()) as CloudflareResponse<PurgeResult>;\n\n    if (!data.success) {\n      const errorMsg = data.errors.map((e) => e.message).join(\", \");\n      throw new Error(errorMsg || \"Failed to purge by prefix\");\n    }\n\n    return true;\n  } catch (error) {\n    console.error(\"Error purging by prefix:\", error);\n    throw error;\n  }\n}\n\nexport function getDefaultZoneId(): string | undefined {\n  const { defaultZoneId } = getPreferenceValues<Preferences>();\n  return defaultZoneId;\n}\n\nexport function extractDomainFromUrl(url: string): string | null {\n  try {\n    const urlObj = new URL(url);\n    return urlObj.hostname;\n  } catch {\n    return null;\n  }\n}\n\nexport async function findZoneByDomain(domain: string): Promise<Zone | null> {\n  const zones = await fetchZones();\n  \n  // Try exact match first\n  let zone = zones.find((z) => z.name === domain);\n  if (zone) return zone;\n\n  // Try to find parent domain match (e.g., subdomain.example.com -> example.com)\n  const parts = domain.split(\".\");\n  while (parts.length > 1) {\n    parts.shift();\n    const parentDomain = parts.join(\".\");\n    zone = zones.find((z) => z.name === parentDomain);\n    if (zone) return zone;\n  }\n\n  return null;\n}\n\nexport async function showErrorToast(message: string, error?: Error) {\n  await showToast({\n    style: Toast.Style.Failure,\n    title: message,\n    message: error?.message,\n  });\n}\n\nexport async function showSuccessToast(message: string) {\n  await showToast({\n    style: Toast.Style.Success,\n    title: message,\n  });\n}\n"],
  "mappings": "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",
  "names": ["quick_purge_exports", "__export", "QuickPurgeCommand", "__toCommonJS", "import_api", "import_react", "import_api", "API_BASE", "getHeaders", "apiToken", "fetchZones", "data", "errorMsg", "e", "error", "purgeUrls", "zoneId", "urls", "data", "API_BASE", "getHeaders", "errorMsg", "e", "error", "getDefaultZoneId", "defaultZoneId", "extractDomainFromUrl", "url", "findZoneByDomain", "domain", "zones", "fetchZones", "zone", "z", "parts", "parentDomain", "showErrorToast", "message", "error", "showSuccessToast", "import_jsx_runtime", "QuickPurgeCommand", "url", "setUrl", "selectedZoneId", "setSelectedZoneId", "zones", "setZones", "isLoading", "setIsLoading", "isSubmitting", "setIsSubmitting", "urlError", "setUrlError", "detectedZone", "setDetectedZone", "initialize", "detectZone", "fetchedZones", "fetchZones", "defaultZoneId", "getDefaultZoneId", "clipboardText", "trimmed", "isValidUrl", "domain", "extractDomainFromUrl", "zone", "findZoneByDomain", "err", "showErrorToast", "text", "urlValue", "z", "validateUrl", "value", "handleSubmit", "values", "purgeUrls", "showSuccessToast"]
}
